# Лабораторная работа 4. Ряд Фибоначчи с помощью итераторов

Лабораторная работа состоит из двух подзаданий: 
1. Создание сопрограммы на основе кода, позволяющей по данному n сгенерировать список элементов из ряда Фибоначчи.
2. Создание программы, возвращающей список чисел Фибоначчи с помощью итератора.

Рассмотрим особенности каждого из них. 

## Задание 1
Стартовый борд: 


На основе приложенного кода в файле ```gen_fib.py``` разработать сопрограмму (_корутину_), реализующую возвращение списка элементов ряда Фибоначчи. 

```python
>> gen = my_genn()

>> gen.send(3) 
[0, 1, 1] 

>> gen.send(5) 
[0, 1, 1, 2, 3] 

>> gen.send(8) 
[0, 1, 1, 2, 3, 5, 8, 13] 

```
Требуется написать необходимые тесты в файле ```test_fib.py```.

## Задание 2
Дополните код классом ```FibonacchiLst``` (пример такого класса представлен в even_numbers_iterator.py), который бы позволял перебирать элементы из ряда Фибоначчи по данному ей списку.
Итератор должен вернуть очередное значение, которое принадлежит ряду Фибоначчи, из данного ей списка. Например: 
для lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1], ```FibonacchiLst``` должен вернуть [0, 1, 2, 3, 5, 8, 1]

Решение может быть выполнено с помощью реализации содержимого методов ```__init__```,```__iter__```, ```__next__``` или с помощью реализации метода ```__getitem__```.

```python

class FibonacchiLst:
    def __init__(self):
        pass
    
    def __iter__(self):
        pass 

    def __next__(self):
        pass

```
Пример реализации итератора, возвращающего четные элементы, из iterable-объекта представлен в файле ```even_numbers_iterator.py```.


### even_numbers_iterator.py

```python
class EvenNumbersIterator():
    
    def __init__(self, instance):
        self.instance = instance   
        self.idx = 0 # инициализируем индекс для перебора элементов
        
        
    def __iter__(self):
        return self # возвращает экземпляр класса, реализующего протокол итераторов
    
    
    def __next__(self): # возвращает следующий по порядку элемент итератора
        while True:
            try:
                res = self.instance[self.idx] # получаем очередной элемент из iterable
                
            except IndexError:
                raise StopIteration

            if res % 2 == 0: # проверяем на четность элемента
                self.idx += 1 # если четный, возвращаем значение и увеличиваем индекс
                return res

            self.idx += 1 # если нечетный, то просто увеличиваем индекс

    
list(EvenNumbersIterator(range(10))) # [0, 2, 4, 6, 8]
```

### gen_fib.py

```python
import functools

def fib_elem_gen():
    """Генератор, возвращающий элементы ряда Фибоначчи"""
    a = 0
    b = 1

    while True:
        yield a
        res = a + b
        a = b
        b = res

g = fib_elem_gen()

while True:
    el = next(g)
    print(el)
    if el > 10:
        break
        
 
       

def my_genn():
    """Сопрограмма"""

    while True:
        number_of_fib_elem = yield
        print(number_of_fib_elem)
        ... # создание элементов ряда Фибоначчи
        # TODO: 
        # Сгенерировать список l, в который положить числа ряда Фиб  
        # по данном number_of_fib_elem (или с помощью yield from или с помощью itertools и функций оттуда 

        l = [str(number_of_fib_elem)+":", 0, 1, 1] # example data
        yield l

def fib_coroutine(g):
    @functools.wraps(g)
    def inner(*args, **kwargs):
        gen = g(*args, **kwargs)
        gen.send(None)
        return gen
    return inner


my_genn = fib_coroutine(my_genn)
gen = my_genn()
print(gen.send(5))
```

### test_fib.py

```python
def test_fib_1():
    gen = my_genn()
    assert gen.send(3) == [0, 1, 1], "Тривиальный случай n = 3, список [0, 1, 1]"


    
def test_fib_2():
    gen = my_genn()
    assert gen.send(5) == [0, 1, 1, 2, 3], "Пять первых членов ряда"

    
# здесь необходимо дополнительно написать несколько тестов для крайних случаев, которые могут возникнуть
```